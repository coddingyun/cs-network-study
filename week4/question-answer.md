# 📌 UDP

## ✅ UDP에 대해 설명해주세요.

인터넷 프로토콜과 거의 같지만 PORT와 체크섬 정보가 추가되어 있다.

수신측에서 제대로 받던 받지 않든 상관 없이 데이터를 보내기만 한다. 그렇기 때문에 데이터 전달 보증도 없고, 순서를 보장해주지도 않는다.

### 특징

**비연결성, 신속한 전송, 데이터 순서 보장하지 않음, 신뢰성 부족, 작은 헤더 크기**

데이터를 작은 패킷인 데이터 그램(Datagram) 형태로 전송한다. 각 데이터 그램은 독립적으로 처리되므로, 패킷이 도착하는 순서가 보장되지 않는다.

### UDP Header

**Source port**: 시작 포트

**Destination port**: 도착지 포트

**Length**: 데이터 그램 길이

**Checksum:** 오류 검출

## ✅ UDP의 장단점을 설명해 주세요.

### 장점

- 비연결형 서비스이므로 연결을 설정하고 해제하는 과정이 존재하지 않는다. 따라서 TCP에 비해 속도가 빠르며 네트워크 부하가 적다.
- 1:1, 1:N, N:N 통신이 가능하다.

### 단점

- 신뢰성있는 데이터의 전송을 보장하지는 못한다. 그렇기 때문에 신뢰성보다는 연속성이 중요한 서비스 예를 들면 실시간 서비스(streaming)에 자주 사용됩니다.

## ✅ UDP 체크섬에 대해 설명해주세요.

헤더와 페이로드에 대한 합성된 값이 해당 체크섬 값과 일치하는지를 확인하여 데이터 그램의 무결성을 검증한다.

- UDP 헤더와 페이로드를 연결하여 하나의 데이터를 만든다.
- 데이터를 16비트 단위로 나눈다.
- 각 16비트 단위의 값을 모두 더한다.
- 이렇게 계산된 값의 하위 16비트를 구한다.
- 최종적으로 체크섬은 이렇게 구한 하위 16비트 값의 보수(ones' complement)를 취하여 얻는다.

# 📌 신뢰적 데이터 전송의 원리

## ✅ 전송후 대기 프로토콜이 뭘까요?

데이터 통신에서 가장 간단한 형태의 흐름 제어 프로토콜이다.

전송후 대기 프로토콜은 패킷을 전송하고 그 패킷에 대한 수신 확인 응답을 받고나서,다음 패킷을 전송하는 방식이다.

`수신자`는 전송받은 프레임에 대해 확인(ACK) 또는 부정(NAK) 신호를 송신자에게 되돌려 보냅니다. `송신자`는 ACK 신호를 받으면 다음 프레임을 전송하고, NAK 신호를 받으면 같은 프레임을 재전송합니다.

이러한 방식은 네트워크 링크 이용률이 낮아 속도가 느리다는 단점이 있습니다.

## ✅ 파이프라인 프로토콜이 뭘까요?

`파이프라인 프로토콜`은 일련의 단계 또는 처리 단계를 통해 데이터를 전송하는 방법

파이프라이닝 프로토콜은 전송한 패킷에 대한 수신 확인 응답을 받지 않고도, 여러 개의 패킷을 연속으로 전송하여 링크 이용률과 전송 속도를 높이는 프로토콜이다.

`파이프라인 프로토콜`을 구현하기 위해 `슬라이딩 윈도우 프로토콜`을 사용합니다.

> `슬라이딩 윈도우 프로토콜`은 수신자로부터 승인을 받기 전에 송신자가 전송할 수 있는 데이터의 양을 규제하는 흐름 제어 메커니즘
> 

# 📌 TCP

## ✅ TCP에 대해 설명해주세요.

TCP는 `Transmission Control Protocol`의 약자로 전송을 제어하는 프로토콜이다.

다음 특징을 가지고 있다.

- **연결지향적** - TCP 3 way handshake (가상, 논리적 연결)
- **데이터 전달 보증**
- **순서 보장**

## ✅ 3 way handshake에 대해 설명해주세요.

TCP 연결 설정 방식이다.

**[STEP 1]**

A클라이언트는 B서버에 접속을 요청하는 `SYN` 패킷을 보낸다. (특정 숫자가 담긴 신호 = Sequence Number 를 보낸다.)

이때 A클라이언트는 SYN 을 보내고 SYN/ACK 응답을 기다리는 `SYN_SENT` 상태가 되는 것이다. 

**[STEP 2]**

B서버는 SYN요청을 받고 A클라이언트에게 요청을 수락한다는 `ACK` 와 `SYN flag` 가 설정된 패킷을 발송하고 A가 다시 ACK으로 응답하기를 기다린다. 이때 B서버는 `SYN_RECEIVED` 상태가 된다.

**[STEP 3]**

A클라이언트는 B서버에게 `ACK`을 보내고 이후로부터는 연결이 이루어지고 데이터가 오가게 되는것이다. 이때의 B서버 상태가 `ESTABLISHED` 이다.

최근에는 최적화가 잘 이루어져서 마지막 3번 과정에서 `ACK`를 보내면서 데이터도 같이 전송한다.

### 이유

클라이언트, 서버 모두 데이터를 전송할 준비가 되었다는 것을 보장하기 위한 것이다.

### **[SYN의 값에 무작위 수를 사용하는 이유?](https://seongonion.tistory.com/74#SYN%EC%9D%98%20%EA%B0%92%EC%97%90%20%EB%AC%B4%EC%9E%91%EC%9C%84%20%EC%88%98%EB%A5%BC%20%EC%82%AC%EC%9A%A9%ED%95%98%EB%8A%94%20%EC%9D%B4%EC%9C%A0%3F-1)**

Connection을 맺을 때 사용하는 포트는 유한 범위 내에서 사용하고 시간이 지남에 따라 재사용된다.

따라서 두 통신 호스트가 과거에 사용된 포트 번호 쌍을 사용할 가능성이 존재한다.

서버 측에서 패킷의 SYN을 보고 패킷을 구분하게 되는데 난수가 아닌 순차적인 숫자가 전송된다면 이전의 connection으로부터 오는 패킷으로 인식할 수 있어 이러한 문제 발생 가능성을 줄이기 위해 ISN을 무작위 난수로 사용하는 것이다.

## ✅ 4 way handshake에 대해 설명해주세요.

TCP 연결 해제 방식이다.

**[STEP 1]**

클라이언트가 연결을 종료하겠다는 `FIN`플래그를 전송한다.

**[STEP 2]**

서버는 일단 확인했다는 `ACK`를 보내고 자신의 통신이 끝날때까지 기다리는데 이 상태가 `CLOSE_WAIT`상태다. 서버는 아직 남은 데이터가 있다면 마저 전송을 마친 후에 close( )를 호출한다. 클라이언트는 서버에서 `ACK`를 받은 후에 서버가 남은 데이터 처리를 끝내고 `FIN` 패킷을 보낼 때까지 기다리게 된다.

**[STEP 3]**

서버가 통신이 끝났으면 연결이 종료되었다고 클라이언트에게 `FIN`플래그를 전송한다. 승인 번호를 보내줄 때까지 기다리는 `LAST_ACK` 상태로 들어간다.

**[STEP 4]**

클라이언트는 FIN을 받고, 확인했다는 `ACK`를 서버에게 보낸다. 아직 서버로부터 받지 못한 데이터가 있을 수 있으므로 `TIME_WAIT`을 통해 기다린다.

### **TCP의 연결 설정 과정(3단계)과 연결 종료 과정(4단계)이 단계가 차이나는 이유**

Client가 데이터 전송을 마쳤다고 하더라도 Server는 아직 보낼 데이터가 남아있을 수 있기 때문에 일단 FIN에 대한 ACK만 보내고, 데이터를 모두 전송한 후에 자신도 FIN 메시지를 보내기 때문이다.

## ✅ TCP 빠른 재전송에 대해서 설명해주세요.

패킷을 받는 수신자 입장에서는 세그먼트로 분할된 내용들이 순서대로 도착하지 않는 경우가 생길 수 있다.

이런 상황이 발생했을 때 수신측에서는 순서대로 잘 도착한 마지막 패킷의 다음 순번을 ACK 패킷에 실어서 보낸다. 그리고 이런 중복 ACK를 받으면 재전송이 이루어진다.

송신 측은 자신이 설정한 `타임아웃` 시간이 지나지 않았어도 바로 해당 패킷을 재전송할 수 있기 때문에 보다 빠른 전송률을 유지할 수 있다.

(혼잡 제어의 한 방식)

## ✅ Congestion control에 대해 설명해주세요.

네트워크 내의 패킷 수가 넘치게 증가하지 않도록 방지한다.

정보의 전송량이 많다면 패킷을 조금만 전송하여 혼잡 붕괴 현상이 일어나는 것을 방지한다.

> 데이터의 양이 라우터가 처리할 수 있는 양을 초과하면 초과된 데이터는 라우터가 처리하지 못한다.
> 
> 
> 송신 측에서는 라우터가 처리하지 못한 데이터를 손실 데이터로 간주하고 계속 재전송하게 되므로 네트워크는 더욱 더 혼잡하게 된다.
> 
> 이런 상황은 송신 측의 전송 속도를 적절히 조절하여 예방할 수 있는데 이것을 혼잡 제어라고 한다.
> 

## ✅ Flow control에 대해 설명해주세요.

수신측이 송신측보다 데이터 처리 속도가 빠르면 문제없지만, 송신측의 속도가 빠를 경우 문제가 생긴다.

데이터 처리 속도를 조절하여 수진자의 버퍼 오버플로우를 방지한다.

데이터를 송신하는 쪽에서 감당이 안될정도로 많은 데이터를 빠르게 보내는 것을 방지한다.

**Stop and Wait**으로 매번 전송한 패킷에 대해 확인 응답을 받아야만 그 다음 패킷을 전송하는 방법이 있다.

**Sliding Window**으로 수신측에서 설정한 윈도우 크기만큼 송신측에서 확인 응답없이 세그먼트를 전송할 수 있게 하여 데이터 흐름을 동적으로 조절하는 방법이 있다.

## 참조

[[네트워크] UDP](https://velog.io/@cjy/네트워크-UDP)

[[CS] UDP란?](https://velog.io/@rlvy98/CS-UDP란)

[TCP, UDP란](https://pro-dev.tistory.com/58)

[[네트워크] 전송 후 대기 프로토콜](https://velog.io/@yoonuk/네트워크-전송-후-대기-프로토콜)

[[네트워크] 파이프라인 프로토콜](https://velog.io/@yoonuk/네트워크-파이프라인-프로토콜)

[[ 네트워크 쉽게 이해하기 22편 ] TCP 3 Way-Handshake & 4 Way-Handshake](https://mindnet.tistory.com/entry/네트워크-쉽게-이해하기-22편-TCP-3-WayHandshake-4-WayHandshake)

[[네트워크] TCP/UDP와 3 -Way Handshake & 4 -Way Handshake](https://velog.io/@averycode/네트워크-TCPUDP와-3-Way-Handshake4-Way-Handshake#-tcp의-4-way-handshake)

[[네트워크] TCP 3-way & 4-way handshake란?](https://seongonion.tistory.com/74)

[TCP 혼잡 제어](https://velog.io/@mu1616/TCPIP-혼잡-제어)

[https://gyoogle.dev/blog/computer-science/network/흐름제어 & 혼잡제어.html](https://gyoogle.dev/blog/computer-science/network/%ED%9D%90%EB%A6%84%EC%A0%9C%EC%96%B4%20&%20%ED%98%BC%EC%9E%A1%EC%A0%9C%EC%96%B4.html)
