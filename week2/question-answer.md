### 📎 HTTP 면접 예상 질문
<details>
  <summary>⭐️ HTTP 프로토콜에 대해서 설명해주세요.</summary>
  Hypertext Transfer Protocol으로, 클라이언트와 서버 간 통신을 위한 프로토콜.
  
  HTML문서와 같은 리소스를 가져올 수 있도록 해주는 프로토콜이다.
  
  애플리케이션 계층 프로토콜이다.
  
  웹 브라우저와 웹 서버의 소통을 위해 디자인 되었다.
</details>

<details>
  <summary>HTTP의 요청/응답 모델에 대해 설명해주세요.</summary>
  요청: 클라이언트가 서버에게 정보를 요청하는 것이다. 요청 메서드를 사용하여 요청의 목적을 명시한다. 요청 메서드 이외에도 헤더와 바디를 포함할 수 있다.

  응답: 서버가 클라이언트에게 요청에 대한 결과를 응답하는 것이다. 응답은 상태 코드와 함께 전송된다. 상태 코드를 통해 요청의 성공 여부 및 종료를 나타낼 수 있다. 응답 메시지에서 또한 헤더와 바디를 포함할 수 있다.
</details>

<details>
  <summary>HTTP 메서드중 GET과 POST의 차이점에 대해 설명해주세요.</summary>
  GET은 읽거나, 검색 할 때에 사용된다. CRUD에서 read에 해당한다. POST는 리소스를 생성하기 위해 사용된다. CRUD에서 create에 해당한다.
  
  GET은 멱등하지만, POST는 멱등하지 않다. 간단하게 설명하자면 GET은 아무리 요청을 보내도 동일한 응답을 가진다. 따라서 멱등하다. 하지만 POST 요청 시 새로 리소스가 생기기 때문에 결과가 달라진다. 따라서 멱등하지 않다.

  또 다른 특징으로는 GET은 캐시될 수 있고, 브라우저에 기록되지만 POST는 그렇지 않다. (GET을 캐시할 때는, HTTP Header에서 cache-control 헤더를 통해 캐시 옵션을 지정할 수 있다)
</details>

<details>
  <summary>HTTP 메서드중 PUT과 PATCH의 차이점에 대해 설명해주세요.</summary>
  PUT은 해당 리소스에 대한 전체 필드를 교체한다. 이에 반해, PATCH는 해당 리소스를 부분적으로 교체 가능하다. 만약 PUT으로 요청할시, 전체가 아닌 일부만 전달할 경우 전달한 필드 외 모두 Null or 초기값으로 처리되는 점을 주의해야한다.

  PUT은 리소스를 아예 교체하는 것이기 때문에 멱등하지 않고, PATCH는 멱등하다
  
</details>

<details>
  <summary>HTTP 상태 코드가 뭔가요? 알고 있는 상태 코드 몇가지 설명해주세요.</summary>
  100: 클라이언트의 요청이 잘 왔으니 계속 진행하라는 의미, 임시 응답
  
  200: 성공
  
  300: 리다이렉션
  
  400: 클라이언트 에러. 401: access token 만료, 404: Not found

  500: 서버 에러
  
</details>

<details>
  <summary>HTTP 헤더가 뭘까요? 알고 있는 헤더 몇 가지 설명해주세요.</summary>
  클라이언트와 서버가 요청 또는 응답으로 부가적인 정보를 전송할 수 있도록 해준다.

  cache-control: 캐시 관리에 대한 정보 표현, 불필요한 네트워크 요청을 줄일 수 있다. (no-cache: 캐시하지 않도록 요청, max-age: 캐시 관리자는 제공한 시간보다 오래된 데이터를 반환하지 않도록 요청, no-cache: 캐시를 재사용하기 전에 서버에 재검증 요청)

  ETag: 리소스가 바뀌었는지 확인하는 식별자. 클라이언트에서 캐싱하고 있는 버전과 서버에서 가지고 있는 버전이 동일하다면 304 Not Modified 라는 상태 코드로만 응답을 내려주어 response body에 대한 트래픽을 아낄 수 있다.
</details>

<details>
  <summary>⭐️ HTTP의 무상태성(Stateless)에 대해서 설명해주세요.</summary>
  stateless: 서버가 클라이언트의 이전 상태를 보존하지 않는다는 의미이다. 서버가 상태를 보관하지 않으므로, 요청에 어느 서버가 응답해도 상관이 없다, 따라서 클라이언트의 요청이 대폭 증가해도 서버를 증설해 해결할 수 있다. 하지만 모든 것을 stateless로 설계할 수는 없다. 로그인 같은 경우에는 서버에 유지시켜 주어야 한다. 
  따라서 쿠키나 세션등을 통해 상태를 유지시킨다.

  +connectioneless: 클라이언트가 서버에 요청을 하고 응답을 받으면 바로 TCP/IP 연결을 끊어 연결을 유지하지 않는 것이다. 이를 통해 서버의 자원을 효율적으로 관리할 수 있다. 하지만 새로 연결될때마다 3-way handshake 시간이 추가된다. 현재는 HTTP 지속 연결로 문제를 해결했다. (keepalive와 연결?)
</details>

<details>
  <summary>HTTP Keep-Alive에 대해서 설명해주세요.</summary>
  HTTP/1.0 버전에서는 요청을 보낼 때마다 연결했다가 끊는 작업을 반복하여 웹 페이지가 느리게 보였다. 그러다 HTTP/1.1 버전에서 keepalive 기능이 추가되었다. (http/1.1부터는 이 동작이 기본, http/1.0에서는 요청 헤더에 Connection: Keep-Alive를 추가해야 한다.)
  
  연결을 한 번 수립하면 데이터 교환을 마칠 때까지 유지하고, 데이터 교환을 모두 끝내면 연결을 끊는 구조이다.
</details>

<details>
  <summary>HTTP 파이프라이닝에 대해서 설명해주세요.</summary>
  HTTP/1.1 버전에서 생김

  최호의 요청이 완료되기 전에 다음 요청을 보내는 기술이다.

  하나의 Connection으로 다수의 Request와 Response를 처리할 수 있게끔 하여 네트워크 Latency를 줄인다. 

  클라이언트가 HTTP 파이프라인을 사용하여 단일 연결을 통해 여러 요청을 보낼 때 서버는 이러한 요청을 수신하고 처리를 위해 대기열에 넣습니다. 그런 다음 서버는 요청이 수신된 순서대로 클라이언트에 응답을 다시 보냅니다. (FIFO) 

  HTTP 2에서는 멀티플렉시 알고리즘으로 대체
</details>

<details>
  <summary>HTTP/1.1, HTTP/2, HTTP/3 각각의 특징에 대해 설명해주세요.</summary>
  HTTP/1.1 버전에서 persistent connection(keepalive), pipelining이 추가됨
  
  HTTP/1.1 버전은 요청은 순서대로 처리하는 특징이 있다. 따라서 이전 요청을 처리하는 데 시간이 길어지면 다음 요청에 대한 처리가 늦어진다. 그렇게 되면 콘텐츠 표시가 늦어진다.
  
  HTTP/2 버전은 요청을 보낸 순서대로 반환하지 않아도 된다. (멀티 플렉싱) 그 외에도 헤더 압축, 서버 추시 기능이 추가되었다. 
  
  헤더 압축: 이전에 표시된 헤더를 제외한 필드를 허프만 코딩을 활요해서 압축, 기존의 연속된 요청에서의 중복 헤더로 인한 오버헤드 문제를 해결

  서버 푸시: 클라이언트가 서버에 요청하지 않아도 클라이언트에게 필요한 리소스를 서버가 추가적으로 push해주는 기능

  HTTP/3 버전에서는 TCP기반이 아닌 UDP기반의 QUIC 계층 위에서 돌아간다. 초기 연결시 3-way handshaking을 하지 않아 시간 감소
</details>


### 📎 HTTPS 면접 예상 질문

<details>
  <summary>HTTPS에 대해서 설명해주세요.</summary>
  HTTPS의 경우 웹페이지를 통해 전송되는 모든 데이터는 추가적인 보안 계층을 지납니다. 이를 SSL/TLS 프로토콜이라고 합니다.
</details>

<details>
  <summary>SSL/TLS이 뭔가요?</summary>
  둘다 보안 통신을 제공하기 위해 설계된 프로토콜, 응용 계층과 전송 계층 사이에 속하게 된다.
  
  TLS는 SSL의 취약점들을 개선한 다음 버전의 프로토콜
</details>

<details>
  <summary>대칭키 암호화 방식에 대해 설명해주세요.</summary>
  하나의 키로 평문을 암호화하고, 다시 암호문을 복호화할 때 사용하는 방식

  키를 한번은 전달해야하는데, 이때 탈취당하게 되면 데이터를 바로 복호화할 수 있다.
  
</details>

<details>
  <summary>전자 서명에 대해서 설명해주세요.</summary>
  - 웹브라우저가 서버에 접속 시, 서버는 제일먼저 인증서를 제공합니다.

  - 브라우저에서는 이 인증서를 발급한 CA가 자신이 내장한 CA 리스트에 있는지 확인합니다.
  
  - 확인 결과 서버를 통해서 다운받은 인증서가 내장된 CA 리스트에 포함되어있다면, 해당 CA의 공개키를 이용해서 인증서를 복호화해봅니다.
</details>

<details>
  <summary>⭐️ HTTPS 암호화 과정에 대해 설명해주세요. (SSL Handshake의 동작 과정을 설명해 주세요.)</summary>
    1. SSL 핸드셰이크(인증 프로세스)를 수행
  
    이때 데이터를 주고받기 위해 어떤 방법을 사용해야 하는지 서로의 상태를 파악한다.
    SSL은 HTTP와 달리 443 포트를 기본으로 사용하는 TCP 기반 프로토콜인데,
    TCP 기반이기 때문에 SSL 핸드셰이크 전에 TCP 3-Way핸드셰이크 또한 수행한다.

  2. 서로 간 협상이 완료되면, SSL 세션이 생성되고 이 후 클라이언트와 서버는 둘만 아는 대칭키로 원하는 데이터를 주고 받는다.

  3. 그리고 데이터 전송이 끝나면 서로에게 알린 후 세션을 종료한다. (세션 키 삭제)
</details>

### 📎 DNS 면접 예상 질문

<details>
  <summary>⭐️ DNS가 뭔가요?</summary>
  간단히 말하자면 DNS는 URL을 IP 주소로 변환하는 시스템이다.
</details>

<details>
  <summary>DNS 작동 방식에 대해 설명해주세요.</summary>
  1. 웹 브라우저에 URL을 입력하여 접속
  
  2. DNS 서버는 해당 요청에 해당하는 도메인 이름의 IP 주소를 알려준다
     
  3. 만약 없다면, 다른 DNS 서버에 요청한다. (DNS 서버는 전 세계에 흩어져 있고, 모두 계층적으로 연결되어 있음)
     
  4. 컴퓨터는 해당 IP주소로 서버에 접속한다
</details>

<details>
  <summary>DNS 질의 종류에 대해 설명해주세요.</summary>
  A 질의: 도메인 이름에 대응하는 IPv4 주소를 찾기 위해 사용
  
  AAAA 질의: 도메인 이름에 대응하는 IPv6 주소를 찾기 위해 사용
  
  CNAME 질의: 도메인 이름에 대해 다른 도메인 이름을 찾기 위해 사용
  
  MX 질의: 도메인 이름에 대응하는 메일 서버의 정보를 찾기 위해 사용
</details>

<details>
  <summary>DNS 서버에게 IP 주소를 요청할 때, 왜 UDP를 사용하나요?</summary>
  빠른 속도
  
    - TCP의 경우 데이터 전송 전에 연결을 맺는 handshaking 과정이 있는 반면, UDP는 연결 설정에 드는 비용이 없다.
    - DNS 질의는 신뢰성보다 빠른 응답 시간이 더 중요하다. 웹 사이트 로딩 속도 향상, 인터넷 대역폭 최적화 등 DNS질의는 빠른 응답성이 중요하다.
    - UDP는 512 바이트를 넘어가지 않는 작은 크기의 패킷만 전송이 가능하고, 오버헤드가 없어 TCP에 비해 상대적으로 빠르다.
  
  연결 상태를 유지할 필요가 없다
  
    - TCP의 패킷 안에는 여러 정보가 담겨 있지만, UDP는 어떤 정보도 기록하지 않고 유지할 필요가 없다.
    - 따라서 DNS 서버는 TCP보다 많은 클라이언트를 수용할 수 있으므로 연결 상태를 유지하지 않고 정보 기록을 최소화할 수 있는 UDP를 채택하였다.
</details>

<details>
  <summary>DNS 레코드가 무엇인가요?</summary>
  DNS 레코드는 DNS 서버가 해당 패킷을 받았을 때 어떤 식으로 처리할지를 나타내는 지침을 말한다.

  A 레코드: 도메인 주소와 서버의 IP 주소를 직접 매핑시키는 방법, 도메인이 바뀌어도 IP는 그대로이므로 유지가 된다. 하지만 서버 이전등의 문제로 IP가 변동될 시에 일일히 변경해야 한다

  CNAME 레코드: 도메인 주소를 또 다른 도메인 주소로 이중 매핑, 서버 이전등의 문제로 IP가 변동될시에 변경하지 않아도 된다. 하지만 도메인이 바뀌면 변경해야 한다, 그리고 여러번 요청이 될 경우 성능 저하가 일어날 수 가 있다.

  AAAA 레코드: A 레코드의 IPv6버전
</details>
